{"version":3,"sources":["tweene.js","common.js","label.js","callback.js","tween-common.js","timeline-common.js","tweene-gsap.js"],"names":[],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACtvBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACnzBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACvDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AC1FA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACtoBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACrdA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"gsap.js","sourcesContent":["/**\n * Tweene - JavaScript Animation Proxy\n * @version 0.5.11\n * @link http://tweene.com\n *\n * Copyright (c) 2014, Federico Orru'   <federico@buzzler.com>\n *\n * @license Artistic License 2.0\n * See LICENSE.txt for details\n *\n */\n\n/* jshint -W008 */\n\n/**\n * Common data and utility functions used internally.\n * None of them is exported.\n */\n\nif(jQuery && window)\n{\n    var $ = jQuery;\n}\n\n// used for recognize transform properties\nvar transformProperties = 'scale|scale3d|translate|translate3d|rotate|rotate3d|rotation|skew|scaleX|scaleY|scaleZ|translateX|translateY|translateZ|x|y|z|rotateX|rotateY|rotateZ|skewX|skewY'.split('|');\n\n// compound transforms are on the begin of the transformProperties array\nvar compoundTransforms = transformProperties.slice(0, 8);\n\n// compound properties we parse to obtain a list of key - value couples\nvar compoundNames = 'margin|padding|borderColor|borderWidth|borderRadius'.split('|');\nvar compoundDirections = ['Top', 'Right', 'Bottom', 'Left'];\nvar radiusDirections = ['TopLeft', 'TopRight', 'BottomRight', 'BottomLeft'];\n\n// base name and aliases for event names. Those with an empty string as value are the names used internally\nvar handlersMap = {\n    begin: '',\n    end: '',\n    progress: '',\n    loop: '',\n    reverse: '',\n    onBegin: 'begin',\n    start: 'begin',\n    onStart: 'begin',\n    onEnd: 'end',\n    complete: 'end',\n    onComplete: 'end',\n    finish: 'end',\n    onFinish: 'end',\n    done: 'end',\n    onProgress: 'progress',\n    update: 'progress',\n    onUpdate: 'progress',\n    onLoop: 'loop',\n    onRepeat: 'loop',\n    onReverse: 'reverse',\n    onReverseComplete: 'reverse'\n};\n\n\n// base name and aliases for option names. Those with an empty string as value are the names used internally\nvar optionsMap = {\n    delay: '',\n    loops: '',\n    loopsDelay: '',\n    yoyo: '',\n    target: '',\n    speed: '',\n    sleep: 'delay',\n    repeat: 'loops',\n    repeatDelay: 'loopsDelay',\n    timeScale: 'speed'\n};\n\n\n// base name and aliases for tween option names\nvar tweenOptionsMap = {\n    easing: '',\n    duration: '',\n    paused: '',\n    to: '',\n    from: '',\n    then: '',\n    ease: 'easing'\n};\n\n\n// predefined easing shortcuts\nvar easings = {\n    linear: [.25, .25, .75, .75],\n    ease: [.25, 0.1, 0.25, 1],\n    'ease-in': [.42, 0, 1, 1],\n    'ease-out': [0, 0, .58, 1],\n    'ease-in-out': [.42, 0, .58, 1],\n    'in': [.42, 0, 1, 1],\n    out: [0, 0, .58, 1],\n    'in-out': [.42, 0, .58, 1],\n    snap: [0, 1, .5, 1],\n    easeInCubic: [.550,.055,.675,.190],\n    easeOutCubic: [.215,.61,.355,1],\n    easeInOutCubic: [.645,.045,.355,1],\n    easeInCirc: [.6,.04,.98,.335],\n    easeOutCirc: [.075,.82,.165,1],\n    easeInOutCirc: [.785,.135,.15,.86],\n    easeInExpo: [.95,.05,.795,.035],\n    easeOutExpo: [.19,1,.22,1],\n    easeInOutExpo: [1,0,0,1],\n    easeInQuad: [.55,.085,.68,.53],\n    easeOutQuad: [.25,.46,.45,.94],\n    easeInOutQuad: [.455,.03,.515,.955],\n    easeInQuart: [.895,.03,.685,.22],\n    easeOutQuart: [.165,.84,.44,1],\n    easeInOutQuart: [.77,0,.175,1],\n    easeInQuint: [.755,.05,.855,.06],\n    easeOutQuint: [.23,1,.32,1],\n    easeInOutQuint: [.86,0,.07,1],\n    easeInSine: [.47,0,.745,.715],\n    easeOutSine: [.39,.575,.565,1],\n    easeInOutSine: [.445,.05,.55,.95],\n    easeInBack: [.6,-.28,.735,.045],\n    easeOutBack: [.175, .885,.32,1.275],\n    easeInOutBack: [.68,-.55,.265,1.55]\n};\n\n\n// predefined duration shortcuts\nvar durations = {\n    fast: '200ms',\n    slow: '600ms'\n};\n\n\n// predefined speed shortcuts\nvar speeds = {\n    half: 0.5,\n    'double': 2\n};\n\n\n\nfunction isFunction(value)\n{\n    return typeof value == 'function';\n}\n\n\n\nfunction isNumber(value)\n{\n    return typeof value == 'number' || (value && typeof value == 'object' && Object.prototype.toString.call(value) == '[object Number]') || false;\n}\n\n\n\nfunction isString(value)\n{\n    return typeof value == 'string' || (value && typeof value == 'object' && Object.prototype.toString.call(value) == '[object String]') || false;\n}\n\n\n\nvar isArray = Array.isArray || function(value)\n{\n    return value && typeof value == 'object' && typeof value.length == 'number' && Object.prototype.toString.call(value) == '[object Array]';\n};\n\n\n\nfunction isObject(value)\n{\n    var type = typeof value;\n    return type === 'function' || type === 'object' && !!value;\n}\n\n\n/*\n * @link http://stackoverflow.com/questions/18082/validate-decimal-numbers-in-javascript-isnumeric\n */\nfunction isNumeric(value)\n{\n    return !isArray(value) && (value - parseFloat(value) + 1) >= 0;\n}\n\n\nfunction isEmpty(obj)\n{\n    for(var name in obj)\n    {\n        if(obj.hasOwnProperty(name))\n        {\n            return false;\n        }\n    }\n    return true;\n}\n\n\n\nfunction seemsPlainObject(value)\n{\n    return  isObject(value) && !(value instanceof Function) && value.constructor == Object;\n}\n\n\n\nfunction extendObject(obj)\n{\n    if (!isObject(obj))\n    {\n        return obj;\n    }\n\n    var source, name, i, length;\n    for (i = 1, length = arguments.length; i < length; i++)\n    {\n        source = arguments[i];\n        for (name in source)\n        {\n            obj[name] = source[name];\n        }\n    }\n    return obj;\n}\n\n\nfunction cloneObject(obj, deep)\n{\n    if (isFunction(obj) || !isObject(obj))\n    {\n        return obj;\n    }\n    if(isArray(obj))\n    {\n        obj = obj.slice();\n        if(deep)\n        {\n            for(var i = 0, end = obj.length; i < end; i++)\n            {\n                obj[i] = cloneObject(obj[i], deep);\n            }\n        }\n    }\n    else\n    {\n        obj = extendObject({}, obj);\n        if(deep)\n        {\n            for(var name in obj)\n            {\n                if(obj.hasOwnProperty(name))\n                {\n                    obj[name] = cloneObject(obj[name], deep);\n                }\n            }\n        }\n    }\n\n    return obj;\n}\n\n\n\nfunction keys(obj)\n{\n    if(Object.keys)\n    {\n        return Object.keys(obj);\n    }\n    var ks = [];\n    for (var key in obj)\n    {\n        if(obj.hasOwnProperty(key))\n        {\n            ks.push(key);\n        }\n    }\n    return ks;\n}\n\n\n// simplified version of Array.indexOf polyfill\nfunction inArray(array, search)\n{\n    if(!isArray(array))\n    {\n        throw 'expected an array as first param';\n    }\n\n    if(array.indexOf)\n    {\n        return array.indexOf(search);\n    }\n\n    for(var i = 0, end = array.length; i < end; i++)\n    {\n        if(array[i] === search)\n        {\n            return i;\n        }\n    }\n    return -1;\n}\n\n\n// used to convert arguments to real array\nfunction toArray(args, pos)\n{\n    if(pos === void 0)\n    {\n        pos = 0;\n    }\n    return Array.prototype.slice.call(args, pos);\n}\n\n\n/**\n * convert time from seconds to milliseconds and vice versa\n *\n * @param {number} value\n * @param {string} fromUnit - 's' | 'ms'\n * @param {string} toUnit - 's' | 'ms'\n * @returns {Number}\n */\nfunction convertTime(value, fromUnit, toUnit)\n{\n    if(fromUnit != toUnit && value !== 0)\n    {\n        return value * (toUnit == 's'? 0.001 : 1000);\n    }\n    return value;\n}\n\n\n\n/*\n *  Based on Bez http://github.com/rdallasgray/bez\n *\n * Copyright Robert Dallas Gray. All rights reserved.\n * Provided under the FreeBSD license: https://github.com/rdallasgray/bez/blob/master/LICENSE.txt\n*/\nfunction bezier(x1, y1, x2, y2)\n{\n    var p1 = [x1, y1], p2 = [x2, y2],\n        A = [null, null], B = [null, null], C = [null, null],\n\n        bezCoOrd = function(time, ax)\n        {\n            C[ax] = 3 * p1[ax]; B[ax] = 3 * (p2[ax] - p1[ax]) - C[ax]; A[ax] = 1 - C[ax] - B[ax];\n            return time * (C[ax] + time * (B[ax] + time * A[ax]));\n        },\n\n        xDeriv = function(time)\n        {\n            return C[0] + time * (2 * B[0] + 3 * A[0] * time);\n        },\n\n        xForT = function(time)\n        {\n            var x = time, i = 0, z;\n            while (++i < 14)\n            {\n                z = bezCoOrd(x, 0) - time;\n                if (Math.abs(z) < 1e-3) break;\n                x -= z / xDeriv(x);\n            }\n            return x;\n        };\n\n    return function(time) {\n        return bezCoOrd(xForT(time), 1);\n    };\n}\n\n\n/**\n * take as input compound properties defined as a space separated string of values and return the list of single value properties\n *\n *   padding: 5 => paddingTop: 5, paddingRight: 5, paddingBottom: 5, paddingLeft: 5\n *   border-width: 2px 1px => borderTopWidth: 2px, borderRightWidth: 1px, borderBottomWidth: 2px, borderLeftWidth: 1px\n *\n * @param {string} name\n * @param {string} value\n * @returns {object}\n */\nfunction compoundMapping(name, value)\n{\n    var parts, nameParts, prefix, suffix, dirs, values = {}, easing, i;\n    if(isArray(value))\n    {\n        value = value[0];\n        easing = value[1];\n    }\n    else\n    {\n        easing = null;\n    }\n\n    parts = String(value).split(/\\s+/);\n\n    switch(parts.length)\n    {\n        case 1: parts = [parts[0], parts[0], parts[0], parts[0]]; break;\n        case 2: parts = [parts[0], parts[1], parts[0], parts[1]]; break;\n        case 3: parts = [parts[0], parts[1], parts[2], parts[1]]; break;\n    }\n\n    nameParts = decamelize(name).split('-');\n    prefix = nameParts[0];\n    suffix = nameParts.length > 1? nameParts[1].substr(0, 1).toUpperCase() + nameParts[1].substr(1) : '';\n\n    dirs = name == 'borderRadius'? radiusDirections : compoundDirections;\n\n    for(i = 0; i < 4; i++)\n    {\n        values[prefix + dirs[i] + suffix] = easing? [parts[i], easing] : parts[i];\n    }\n    return values;\n}\n\n\n/**\n *  split commpound transform values\n *\n *   scale: 1.2 => scaleX: 1.2, scaleY: 1.2\n *   rotate3d: 30, 60, 40 => rotateX: 30, rotateY: 60, rotateZ: 40\n *\n * @param {string} name\n * @param {string} value\n * @returns {object}\n */\nfunction transformMapping(name, value)\n{\n    var easing, dirs = ['X', 'Y', 'Z'], values = {}, parts, baseName;\n    if(isArray(value))\n    {\n        value = value[0];\n        easing = value[1];\n    }\n    else\n    {\n        easing = null;\n    }\n\n    parts = String(value).split(/\\s*,\\s*/);\n    baseName = name.indexOf('3') !== -1? name.substr(0, name.length - 2) : name;\n\n    if(name == 'rotate3d')\n    {\n        if(parts.length == 4)\n        {\n            dirs = [parts[0] == '1'? 'X' : (parts[1] == '1'? 'Y' : 'Z')];\n            parts[0] = parts[3];\n        }\n        else\n        {\n            throw 'invalid rotate 3d value';\n        }\n    }\n    else\n    {\n        switch(parts.length)\n        {\n            // for rotations, a single value is passed as Z-value, while for other transforms it is applied to X and Y\n            case 1:\n                parts = baseName == 'rotate' || baseName == 'rotation'? [null, null, parts[0]] : [parts[0], parts[0], null];\n            break;\n\n            case 2:\n                parts = [parts[0], parts[1], null];\n            break;\n        }\n\n    }\n\n    for(var i = 0; i < dirs.length; i++)\n    {\n        if(parts[i] !== null)\n        {\n            values[baseName + dirs[i]] = easing? [parts[i], easing] : parts[i];\n        }\n    }\n    return values;\n}\n\n\n\nfunction isTransformProperty(name)\n{\n    return (inArray(transformProperties, name) != -1);\n}\n\n\n// border-bottom-width -> borderBottomWidth\nfunction camelize(name)\n{\n    return name.replace(/(\\-[a-z])/g, function(value) {\n        return value.substr(1).toUpperCase();\n    });\n}\n\n\n// borderBottomWidth -> border-bottom-width\nfunction decamelize(name)\n{\n    return name.replace(/([A-Z])/g, '-$1').toLowerCase();\n}\n\n\n/**\n * accept a speed name shortcuts or a number and give back an acceptable positive value.\n * Fallback to 1 if value is out of valid range\n *\n * @param {string|number} value\n * @returns {number}\n */\nfunction parseSpeed(value)\n{\n    if(value in speeds)\n    {\n        value = speeds[value];\n    }\n\n    value = parseFloat(value);\n    if(isNaN(value) || !value || value <= 0)\n    {\n        value = 1;\n    }\n    return value;\n}\n\n\n\n\n/**\n * Tweene global class, is the unique identifier exported\n *\n * You will never need to instantiate a Tweene object. You have to use Tweene static methods\n * in order to obtain instances of tween and timeline objects of the different drivers\n *\n * @class\n *\n */\nvar Tweene = function()\n{\n    var _self = this;\n\n    // used for generate unique identifier for any tweene object (tweens, timelines, callbacks and labels)\n    this._idCounter = 0;\n\n    // internally, all time values use this unit\n    this._coreTimeUnit = 'ms';\n\n    // time unit used when pure numbers are passed as delay or duration values. Users can change this value any time\n    // when the user requires only GSAP driver, it defaults to 's' in order to mimic the library native API\n    this.defaultTimeUnit = 'ms';\n\n    this._macros = {};\n\n    this.easings = easings;\n\n    this.durations = durations;\n\n    this.speeds = speeds;\n\n    this.defaultDriver = 'jquery';\n\n    this.defaultEasing = 'easeOutQuad';\n\n    this.defaultDuration = '400ms';\n\n    // container for registered drivers\n    var _drivers = {\n            tween: {},\n            timeline: {}\n        },\n\n\n        /**\n         * Create a tween or timeline object of the specified driver. If driverName is not given, it fallbacks to default driver\n         *\n         * @param {string} 'tween' or 'timeline'\n         * @param {string} [driverName] - one of the registered driver's name\n         * @returns {object} tween or timeline object\n         */\n        _getInstance = function(type, driverName)\n        {\n            var d, i;\n            driverName = (driverName? driverName : _self.defaultDriver).toLowerCase();\n\n            if(driverName in _drivers[type])\n            {\n                d = _drivers[type][driverName];\n                i = new d();\n                i.driverName = driverName;\n                return i;\n            }\n            throw 'Driver ' + name + ' not found';\n        },\n\n\n        /**\n         * Common method used inside from(), to() and fromTo() to create a tween and pass arguments to it\n         *\n         * @param {arguments} args - list of arguments passed to original public method\n         * @param {string} method - 'from' | 'to' | 'fromTo'\n         * @returns {object} - return a tween object\n         */\n        _tweenNow = function(args, method)\n        {\n            var tw = _getInstance('tween');\n            if(args.length)\n            {\n                args = toArray(args, 0);\n                tw.target(args.shift())[method].apply(tw, args);\n            }\n\n            return tw._immediateStart? tw.play() : tw;\n        };\n\n\n    /**\n     * Register an animation driver\n     *\n     * @param {string} name - name of the driver\n     * @param {string} type - 'tween' | 'timeline'\n     * @param {function} construct - constructor function that defines the driver class\n     * @returns {Tweene}\n     */\n    this.registerDriver = function(name, type, construct)\n    {\n        type = type.toLowerCase();\n        if(type != 'tween')\n        {\n            type = 'timeline';\n        }\n        _drivers[type][name.toLowerCase()] = construct;\n        return this;\n    };\n\n\n    /**\n     * Define a macro for tween objects\n     * @link http://tweene.com/docs/#macro\n     *\n     * @param {string} name\n     * @param {function} macro - inside the function, 'this' refers to the tween object\n     * @returns {Tweene}\n     */\n    this.registerMacro = function(name, macro)\n    {\n        this._macros[name] = macro;\n        return this;\n    };\n\n\n    /**\n     * Return an instance of a tween object\n     * @link http://tweene.com/docs/#createTween\n     *\n     * @param {object|string} [target] jquery object or string selector of the dom element(s) to be animated\n     * @param {string} [driver]\n     * @returns {object}\n     */\n    this.get = function(target, driver)\n    {\n        var t = _getInstance('tween', driver);\n        return target? t.target(target) : t;\n    };\n\n\n    /**\n     * Apply instantly the properties values to the target\n     *\n     * @param {object|string} target\n     * @param {object} values - CSS property - value map\n     * @returns {unresolved}\n     */\n    this.set = function(target, values)\n    {\n        return _getInstance('tween').target(target).set(values);\n    };\n\n\n    /**\n     * Create a tween object for a 'to' animation and pass the arguments to it. First argument is always the target.\n     * If you don't set paused: true in the options passed, the tween will start immediately.\n     * @link http://tweene.com/docs/#tweenTo\n     *\n     * @returns {object} - return the tween object\n     */\n    this.to = function()\n    {\n        return _tweenNow(arguments, 'to');\n    };\n\n\n    /**\n     * Create a tween object for a 'from' animation and pass the arguments to it. First argument is always the target.\n     * If you don't set paused: true in the options passed, the tween will start immediately.\n     * @link http://tweene.com/docs/#tweenFrom\n     *\n     * @returns {object} - return the tween object\n     */\n    this.from = function()\n    {\n        return _tweenNow(arguments, 'from');\n    };\n\n\n    /**\n     * Create a tween object for a 'fromTo' animation and pass the arguments to it. First argument is always the target.\n     * If you don't set paused: true in the options passed, the tween will start immediately.\n     * @link http://tweene.com/docs/#tweenFromTo\n     *\n     * @returns {object} - return the tween object\n     */\n    this.fromTo = function()\n    {\n        return _tweenNow(arguments, 'fromTo');\n    };\n\n\n    /**\n     * Create a timeline object\n     * @link http://tweene.com/docs/#createTimeline\n     *\n     * @param {object|string} [target] - it checks if the object passed as first param is a plain object (options) or not (target)\n     * @param {object} [options]\n     * @param {string} driver - name of the driver\n     * @returns {object} - a timeline object\n     */\n    this.line = function(target, options, driver)\n    {\n        // we assume that targets cannot be plain objects\n        var lineTarget = (isObject(target) && !seemsPlainObject(target))  || isString(target)? target : null;\n        // if no target is passed, unshift arguments by one position\n        if(!lineTarget)\n        {\n            options = arguments[0];\n            driver = arguments[1];\n        }\n        options = seemsPlainObject(options)? options : {};\n        // driver can be specified also with a 'driver' property inside options object\n        driver = (driver !== void 0)? driver : 'driver' in options? options.driver : null;\n        return _getInstance('timeline', driver)\n            .options(options)\n            .target(lineTarget);\n    };\n\n};\n\nvar Tw = new Tweene();\n\nif(window)\n{\n    window.Tweene = Tw;\n}\n","/**\n * Tweene - JavaScript Animation Proxy\n *\n * @link http://tweene.com\n *\n * Copyright (c) 2014, Federico Orru'   <federico@buzzler.com>\n *\n * @license Artistic License 2.0\n * See LICENSE.txt for details\n *\n */\n\n\n\n/**\n * Vars and methods common to every tween and timeline, whatever is the driver used\n * @mixin\n *\n */\nvar Common = function()\n{\n    // unique identifier\n    this._id = ++ Tw._idCounter;\n    this._coreTimeUnit = Tw._coreTimeUnit;\n    this._timeUnit = Tw.defaultTimeUnit;\n\n    this._parent = null;\n\n    this._target = null;\n\n    this._duration = 0;\n\n    this._speed = 1;\n\n    this._delay = 0;\n\n    this._loops = 0;\n\n    this._loopsDelay = 0;\n\n    this._loopsCount = 0;\n\n    this._yoyo = false;\n\n    this._fwd = true;\n\n    this._localFwd = true;\n\n    this._ready = false;\n\n    this._running = false;\n\n    // event handlers set by user\n    this._handlers = {\n        begin: null,\n        end: null,\n        reverse: null,\n        progress: null,\n        loop: null\n    };\n\n    // event handlers set internally\n    this._coreHandlers = {\n        _begin: [],\n        _end: [],\n        begin: [],\n        end: [],\n        reverse: [],\n        progress: [],\n        loop : []\n    };\n\n\n    /**\n     * Play the animation in forward direction\n     * @link http://tweene.com/docs/#play\n     *\n     * @returns {this}\n     */\n    this.play = function()\n    {\n        this._fwd = true;\n        this._playTween();\n        return this;\n    };\n\n\n    /**\n     * Play the animation in backward direction from its current position\n     * @link http://tweene.com/docs/#reverse\n     *\n     * @returns {this}\n     */\n    this.reverse = function()\n    {\n        this._fwd = false;\n        this._reverseTween();\n        return this;\n    };\n\n\n    /**\n     * Pause the animation on its current state.\n     * @link http://tweene.com/docs/#pause\n     *\n     * @returns {this}\n     */\n    this.pause = function()\n    {\n        if(this._ready)\n        {\n            this._pauseTween();\n        }\n        return this;\n    };\n\n\n    /**\n     * Resume a previously paused animation without affecting the current direction\n     * @link http://tweene.com/docs/#resume\n     *\n     * @returns {this}\n     */\n    this.resume = function()\n    {\n        this._resumeTween();\n        return this;\n    };\n\n\n    /**\n     * Restart animation in forward direction.\n     * Reset also loops counter.\n     * Initial delay is performed only on the very first start, not on restart.\n     * @link http://tweene.com/docs/#restart\n     *\n     * @returns {this}\n     */\n    this.restart = function()\n    {\n        this._restartTween();\n        return this;\n    };\n\n\n    /**\n     * Go back to initial or final position accordingly to the value of direction. Intended to be used internally, you don't have to call this directly.\n     *\n     * @returns {this}\n     */\n    this.back = function()\n    {\n        this._backTween(this._localFwd? 'begin' : 'end');\n        return this;\n    };\n\n\n    /**\n     * Get or set the speed of the current tween/timeline. Normal speed is 1, so 2 is double speed and 0.5 is half speed.\n     * It's usable both before and during the animation.\n     * It Accepts also string shortcut defined in Tweene.speeds\n     * @link http://tweene.com/docs/#speedControl\n     *\n     * @param {number} [value]\n     * @returns {number|this}\n     */\n    this.speed = function(value)\n    {\n        if(value === void 0)\n        {\n            return this._speed;\n        }\n\n        value = parseSpeed(value);\n        if(value != this._speed)\n        {\n            this._speed = value;\n            this._speedTween();\n        }\n        return this;\n    };\n\n\n    /**\n     * Alias for speed()\n     * @see speed\n     *\n     */\n    this.timeScale = function()\n    {\n        return this.speed.apply(this, arguments);\n    };\n\n\n    /**\n     * Return the current playhead time (a value between 0 and duration) in time unit set in Tweene.defaultTimeUnit\n     *\n     * @returns {number}\n     */\n    this.time = function()\n    {\n        return Math.round(convertTime(this._getPosition(), this._coreTimeUnit, this._timeUnit) * 1000) / 1000;\n    };\n\n\n    /**\n     * Return the current playhead position in percent (a value between 0 and 1)\n     *\n     * @returns {number}\n     */\n    this.progress = function()\n    {\n        return Math.round(this._getProgress() * 1000) / 1000;\n    };\n\n\n    /**\n     * Return true if the animation is currently paused\n     * Tt's true also when the animation is finished or not yet started\n     *\n     * @returns {boolean}\n     */\n    this.paused = function()\n    {\n        return this._getPaused();\n    };\n\n\n    /**\n     * Return true if the animation direction is currently reversed\n     *\n     * @returns {boolean}\n     */\n    this.reversed = function()\n    {\n        return !this._fwd;\n    };\n\n\n    /**\n     * Get/Set the tween duration (only get available for timeline)\n     * Accept numeric values interpreted as Tweene.defaultTimeUnit\n     * or string with unit suffix, so '500ms' or '0.5s'\n     *\n     * @param {string|number} [value]\n     * @returns {this|number}\n     *\n     */\n    this.duration = function(value)\n    {\n        if(value !== void 0)\n        {\n            if(this._type != 'timeline')\n            {\n                this._duration = this._parseTime(value);\n                this.invalidate();\n            }\n            return this;\n        }\n\n        // timeline needs to process its children in order to calculate the overall duration\n        if(this.type == 'timeline')\n        {\n            this.prepare();\n        }\n        return Math.round(convertTime(this._duration, this._coreTimeUnit, this._timeUnit) * 1000) / 1000;\n    };\n\n\n    /**\n     * Get the tween/timeline total duration including loops and loopsDelay, in the timeUnit set in Tweene.defaultTimeUnit\n     * In case of infinite loop, it returns Infinity\n     *\n     * @returns {number}\n     */\n    this.totalDuration = function()\n    {\n        if(this.type == 'timeline')\n        {\n            this.prepare();\n        }\n        return Math.round(convertTime(this._getTotalDuration() * this._speed, this._coreTimeUnit, this._timeUnit) * 1000) / 1000;\n    };\n\n\n    /**\n     * Set the animation target (jquery or dom objects commonly, accordingly to the specific animation library in use)\n     * @link http://tweene.com/docs/#target\n     *\n     * @param {string|object} [value]\n     * @returns {string|object|this}\n     */\n    this.target = function(value)\n    {\n        if(value === void 0)\n        {\n            return this._target;\n        }\n        this._setTarget(value);\n        return this;\n    };\n\n\n    /**\n     * Get/Set the tween initial delay\n     * Accept numeric values interpreted as Tweene.defaultTimeUnit\n     * or string with unit suffix, so '500ms' or '0.5s'\n     * @link http://tweene.com/docs/#delay\n     *\n     * @param {string|number} [value]\n     * @returns {number|this}\n     */\n    this.delay = function(value)\n    {\n        if(value === void 0)\n        {\n            return convertTime(this._delay, this._coreTimeUnit, this._timeUnit);\n        }\n        this._delay = this._parseTime(value);\n        this.invalidate();\n        return this;\n    };\n\n\n\n    /**\n     * Set the number of animation repeats. Default is 0, so loops(1) will execute the tween/timeline twice.\n     * A value of -1 means 'Infinite loop'.\n     * @link http://tweene.com/docs/#loops\n     *\n     * @param {number} value\n     * @returns {this}\n     */\n    this.loops = function(value)\n    {\n        if(value === void 0)\n        {\n            return this._loops;\n        }\n        value = parseInt(value);\n        if(isNaN(value))\n        {\n            value = 0;\n        }\n        else if(!isFinite(value))\n        {\n            value = -1;\n        }\n        this._loops = value;\n        this.invalidate();\n        return this;\n    };\n\n\n    /**\n     * Enable/disable yoyo behavior or retrieve its status.\n     * Yoyo makes sense only when used with looops.\n     * @link http://tweene.com/docs/#yoyoEffect\n     *\n     * @param {boolean} [value]\n     * @returns {boolean|this}\n     */\n    this.yoyo = function(value)\n    {\n        if(value === void 0)\n        {\n            return this._yoyo;\n        }\n        this._yoyo = !!value;\n        return this;\n    };\n\n\n    /**\n     * Get/Set the value of delay before each loop iteration\n     * Accept numeric values interpreted as Tweene.defaultTimeUnit\n     * or string with unit suffix, so '500ms' or '0.5s'\n     * @link http://tweene.com/docs/#loopsDelay\n     *\n     * @param {string|number} [value]\n     * @returns {number|this}\n     */\n    this.loopsDelay = function(value)\n    {\n        if(value === void 0)\n        {\n            return convertTime(this._loopsDelay, this._coreTimeUnit, this._timeUnit);\n        }\n        this._loopsDelay = this._parseTime(value);\n        this.invalidate();\n        return this;\n    };\n\n\n    /**\n     * Add event handler.\n     * First param is the event name,\n     * second param is the callback function,\n     * third (optional) array of params to pass to the callback\n     * fourth (optional) scope for the callback (the default is the tween / timeline object that will raise the event)\n     *\n     * Available events:\n     *  begin | onBegin | start | onStart:\n     *      raised on the animation start\n     *\n     *  end | onEnd | complete | onComplete | finish | onFinish | done:\n     *      raised on the animation end, after all loops (a tween with infinite loops will never fire this event)\n     *\n     *  reverse | onReverse | onReverseComplete:\n     *      raised when the animation ends in backward direction, so at the start position.\n     *\n     *  progress | onProgress | update | onUpdate:\n     *      fires periodically during the tween. The frequency of the call\n     *      could be different for any animation library used.\n     *      When the library does not offer native progress event, it is emulated\n     *      via RequestAnimationFrame\n     *\n     *  loop | onLoop | onRepeat:\n     *      raised on each loop iteration\n     *\n     *\n     * @link http://tweene.com/docs/#events\n     *\n     * @param {string} name\n     * @param {function|null} callback - pass null to remove a previously set event handler\n     * @param {array} [params]\n     * @param {object} [scope]\n     * @returns {this}\n     */\n    this.on = function(name, callback)\n    {\n        if(name in handlersMap)\n        {\n            name = handlersMap[name].length? handlersMap[name] : name;\n            if(callback === null)\n            {\n                this._handlers[name] = null;\n            }\n            else\n            {\n                this._handlers[name] = {\n                    callback: callback,\n                    params: arguments.length > 2? (isArray(arguments[2])? arguments[2] : [arguments[2]]) : [],\n                    scope: arguments.length > 3 && arguments[3] !== null? arguments[3] : this\n                };\n            }\n        }\n        return this;\n    };\n\n\n    /**\n     * Used internally for register core event handlers\n     *\n     * @param {string} name\n     * @param {string} id\n     * @param {function} callback\n     * @param {object} [scope]\n     * @param {array} [params]\n     * @param {boolean} [priority]\n     * @returns {this}\n     */\n    this.setCoreHandler = function(name, id, callback, scope, params, priority)\n    {\n        this.unsetCoreHandler(name, id);\n        var entry = {id: id, callback: callback, scope: scope || this, params: params || []};\n\n        if(priority)\n        {\n            this._coreHandlers[name].unshift(entry);\n        }\n        else\n        {\n            this._coreHandlers[name].push(entry);\n        }\n\n        return this;\n    };\n\n\n    /**\n     * Used internally for unregister core event handlers\n     *\n     * @param {string} name\n     * @param {string} id\n     * @returns {this}\n     */\n    this.unsetCoreHandler = function(name, id)\n    {\n        for(var i = 0, end = this._coreHandlers[name].length; i < end; i++)\n        {\n            if(this._coreHandlers[name][i].id == id)\n            {\n                this._coreHandlers[name].splice(i, 1);\n                break;\n            }\n        }\n        return this;\n    };\n\n\n    /**\n     * Reset _ready flag every time that one of the internal properties that need to be processed before running is changed\n     *\n     * @returns {this}\n     */\n    this.invalidate = function()\n    {\n        if(!this._running)\n        {\n            if(this._parent)\n            {\n                this._parent.invalidate();\n            }\n            this._ready = false;\n        }\n        return this;\n    };\n\n\n    /**\n     * Get/Set the parent object. The parent could be a timeline or a tween if the child is a DummyTween used for emulate delay\n     *\n     * @param {object} [value]\n     * @returns {this|object}\n     */\n    this.parent = function(value)\n    {\n        if(value === void 0)\n        {\n            return this._parent;\n        }\n        this._parent = value;\n        this.invalidate();\n        return this;\n    };\n\n\n    /**\n     * Get the internal unique identifier\n     *\n     * @returns {number}\n     */\n    this.id = function()\n    {\n        return this._id;\n    };\n\n\n    /**\n     * Set options for tween or timeline\n     *\n     * @param {object} options\n     * @returns {this}\n     */\n    this.options = function(options)\n    {\n        // the object will be modified, we need to clone it in order to keep the original safe, allowing its reuse\n        options = cloneObject(options, true);\n        var opts = this._parseOptions(options);\n        opts.events = this._parseEvents(options);\n        this._applyArguments(opts);\n        return this;\n    };\n\n\n    /**\n     * Return the resulting speed of the object\n     *\n     * @returns {number}\n     */\n    this.getRealSpeed = function()\n    {\n        return this._parent? this._parent.getRealSpeed() * this._speed : this._speed;\n    };\n\n\n    /**\n     * Get the tween/timeline total duration including loops and loopsDelay\n     * In case of infinite loop, it returns Infinity\n     *\n     * @returns {number}\n     */\n    this._getTotalDuration = function()\n    {\n        if(this._loops == -1 && (this._duration || this._loopsDelay))\n        {\n            return Infinity;\n        }\n        return (this._duration + ((this._loopsDelay + this._duration) * this._loops)) / this._speed;\n    };\n\n\n    /**\n     * Assign otpions and event handlers previously parsed\n     *\n     * @param {object} args\n     */\n    this._applyArguments = function(args)\n    {\n        var name;\n        for(name in args.events)\n        {\n            this.on.apply(this, args.events[name]);\n        }\n        delete args.events;\n\n        for(name in args)\n        {\n            // these properties are available only for tween objects\n            if(this.type != 'timeline' && inArray(['from', 'to', 'then', 'immediateStart'], name) != -1)\n            {\n                this['_' + name] = args[name];\n            }\n            else if(name in this && this[name] instanceof Function)\n            {\n                this[name](args[name]);\n            }\n        }\n    };\n\n\n    /**\n     * Check if there are public or internal event handlers set for that name\n     *\n     * @param {string} name\n     * @returns {boolean}\n     */\n    this._hasHandlers = function(name)\n    {\n        return (name in this._handlers && this._handlers[name] !== null) || this._coreHandlers[name].length;\n    };\n\n\n    /**\n     * execute event handlers bound to the given name\n     *\n     * @param {string} name\n     */\n    this._runHandlers = function(name)\n    {\n        var i, end, entry;\n\n        // run external events first to guarantee correct events order inside timelines\n        if(name in this._handlers && this._handlers[name] !== null)\n        {\n            entry = this._handlers[name];\n            entry.callback.apply(entry.scope, entry.params);\n        }\n\n        // internal handlers\n        if(this._coreHandlers[name].length)\n        {\n            for(i = 0, end = this._coreHandlers[name].length; i < end; i++)\n            {\n\n                entry = this._coreHandlers[name][i];\n                entry.callback.apply(entry.scope, entry.params);\n            }\n        }\n\n    };\n\n\n\n\n    /**\n     * find and return allowed options in a generic object\n     *\n     * @param {Object} options\n     * @param {Boolean} remove - if true, it removes found options from original object\n     * @returns {Object}\n     */\n    this._parseOptions = function(options, remove)\n    {\n        var opts = this.type == 'tween'? extendObject({}, optionsMap, tweenOptionsMap) : optionsMap,\n            values = {}, name, realName, value;\n\n        for(name in options)\n        {\n            if(options.hasOwnProperty(name) && name in opts)\n            {\n                value = options[name];\n                // paused property is used internally for another purpose, so we have to handle this option separately\n                if(name == 'paused')\n                {\n                    this._immediateStart = !value;\n                    delete options[name];\n                    continue;\n                }\n\n                realName = opts[name].length? opts[name] : name;\n                values[realName] = value;\n                if(remove)\n                {\n                    delete options[name];\n                }\n\n            }\n        }\n        return values;\n    };\n\n\n\n    /**\n     * Find and return allowed event in a generic object\n     *\n     * @param {object} options\n     * @param {boolean} remove - if true, it removes found handlers and related values (scope and params) from original object\n     * @returns {object}\n     */\n    this._parseEvents = function (options, remove)\n    {\n        var values = {}, value, args, name, realName, params;\n        for(name in options)\n        {\n            if(options.hasOwnProperty(name) && name in handlersMap)\n            {\n                value = options[name];\n                realName = handlersMap[name].length? handlersMap[name] : name;\n                args = [realName, value];\n                if(remove)\n                {\n                    delete options[name];\n                }\n                if((name + 'Params') in options)\n                {\n                    params = options[name + 'Params'];\n                    args.push(isArray(params) ? params : [params]);\n                    if(remove)\n                    {\n                        delete options[name + 'Params'];\n                    }\n                }\n                if((name + 'Scope') in options)\n                {\n                    args.push(options[name + 'Scope']);\n                    if(remove)\n                    {\n                        delete options[name + 'Scope'];\n                    }\n                }\n                else\n                {\n                    args.push(this);\n                }\n                values[realName] = args;\n            }\n        }\n        return values;\n    };\n\n\n    /**\n     * Parse time value used for delay and duration settings, return a number that is the time expressed in coreTimeUnit.\n     * Fallback to 0 if the given value is not valid\n     *\n     * @param {string|number} value\n     * @returns {number}\n     */\n    this._parseTime = function(value)\n    {\n        if(!value)\n        {\n            return 0;\n        }\n        var unit = this._timeUnit, parts;\n        if(isString(value))\n        {\n            // check for duration shortcuts like 'slow', 'fast', and so on\n            if(value in durations)\n            {\n                value = durations[value];\n            }\n\n            // accept 's' or 'ms' as suffix after the number\n            parts = value.match(/^[\\+\\-]?\\s*([0-9\\.]+)\\s*(m?s)?$/i);\n            if(parts === null || parts[1] === void 0)\n            {\n                return 0;\n            }\n            if(parts[2] !== void 0)\n            {\n                unit = parts[2].toLowerCase();\n            }\n            value = parts[1];\n        }\n        value = Number(value);\n\n        if(isNaN(value))\n        {\n            value = 0;\n        }\n\n        value = convertTime(value, unit, this._coreTimeUnit);\n\n        return Math.max(0, value);\n    };\n\n\n    /**\n     * Set the target for tween or timeline. It accept both an object or a selector string\n     *\n     * @param {string|object} value\n     * @returns {this}\n     */\n    this._setTarget = function(value)\n    {\n        if(isString(value) && '$' in window)\n        {\n            value = $(value);\n        }\n        this._target = value;\n        return this;\n    };\n\n\n};\n","/**\n * Tweene - JavaScript Animation Proxy\n *\n * @link http://tweene.com\n *\n * Copyright (c) 2014, Federico Orru'   <federico@buzzler.com>\n *\n * @license Artistic License 2.0\n * See LICENSE.txt for details\n *\n */\n\n\n/**\n * Create a Label object, used internally by timelines when you add a label\n * @class\n *\n * @param {string} name\n */\nvar Label = function(name)\n{\n    this.type = 'label';\n    this._id = name;\n    this._name = name;\n    this._position = null;\n\n\n    /**\n     * Return the unique identifier\n     *\n     * @returns {number}\n     */\n    this.id = function()\n    {\n        return this._id;\n    };\n\n\n    /**\n     * Get/Set the time position inside the parent timeline\n     *\n     * @param {number} [value]\n     * @returns {this}\n     */\n    this.position = function(value)\n    {\n        if(value === void 0)\n        {\n            return this._position;\n        }\n        this._position = value;\n        return this;\n    };\n\n};\n","/**\n * Tweene - JavaScript Animation Proxy \n * \n * @link http://tweene.com\n *   \n * Copyright (c) 2014, Federico Orru'   <federico@buzzler.com>\n * \n * @license Artistic License 2.0 \n * See LICENSE.txt for details\n * \n */\n\n\n/**\n * Create a Callback object, used internally by timelines when you add callbacks calls\n * @class\n * \n * @param {function} callback\n * @param {object} scope\n * @param {array} params\n * @param {number} dir - values: 1 | -1 | 0\n */\nvar Callback = function(callback, scope, params, dir, isPause)\n{\n    this.type = 'callback';    \n    // unique id\n    this._id = ++ Tw._idCounter;\n    \n    this.isPause = !!isPause;\n    \n    dir = dir === 1? true : (dir === -1? false : null);\n    var parent = null;\n            \n    /**\n     * Get or set the parent timeline object\n     * \n     * @param {object} [value] - parent object\n     * @returns {object|this}\n     */\n    this.parent = function(value)\n    {\n        if(!value)\n        {\n            return parent;\n        }\n        parent = value;\n        return this;                \n    };\n    \n    \n    /**\n     * Return the unique identifier\n     * \n     * @returns {number} \n     */\n    this.id = function()\n    {\n        return this._id;\n    };\n    \n    \n    /**\n     * Duration of a callback inside a timeline is always 0, this is needed because internally they are handled as tweens\n     * \n     * @returns {number}\n     */\n    this.totalDuration = function()\n    {\n        return 0;\n    };\n    \n        \n    /**\n     * Execute the callback if the parent's direction is coherent with the callback's dir value\n     * \n     * @returns {this}\n     */\n    this.resume = function()\n    {\n        if(callback && (dir === null || dir != parent.reversed()))\n        {\n            callback.apply(scope || parent, params);\n        }\n        return this;\n    };\n    \n    \n    \n};\n\n","/**\n * Tweene - JavaScript Animation Proxy \n * \n * @link http://tweene.com\n *   \n * Copyright (c) 2014, Federico Orru'   <federico@buzzler.com>\n * \n * @license Artistic License 2.0 \n * See LICENSE.txt for details\n * \n */\n\n\n/**\n * Vars and methods common to every tween, whatever is the driver used\n * @mixin\n * \n */\nvar TweenCommon = function()\n{    \n    this.type = 'tween';\n\n    this._from = null;\n\n    this._to = null;\n\n    this._then = null;\n\n    this._easing = Tw.defaultEasing;\n\n    this._duration = this._parseTime(Tw.defaultDuration);\n\n    // could be overriden inside each driver\n    this._propertyMap = {};\n\n    this._hasMultipleEasing = false;\n    this._allowMultipleEasing = false;\n    this._allowTransform = false;        \n\n    this._immediateStart = true;                \n\n    this._data = null;    \n\n    this._offset = 0;\n\n\n\n    /**\n     * Used by parent timeline to set the time offset of the tween\n     * \n     * @param {number} value\n     * @returns {this}\n     */\n    this.offset = function(value)\n    {\n        this._offset = value;\n        return this;\n    };\n\n\n    /**\n     * Create and return a timeline using target and driver of the current object\n     * \n     * @param {object} params\n     * @returns {object}\n     */\n    this.line = function(params)\n    {\n        return Tw.line(this._target, params, this.driverName);\n    };\n\n\n    /**\n     * Execute a previously registered macro using this as macro scope\n     * \n     * @param {string} name - the name of the macro\n     * @returns {this}\n     */\n    this.exec = function(name)\n    {\n        // all arguments but the first will be passed to the macro\n        var args = toArray(arguments, 1);\n        if(name && name in Tw._macros)\n        {\n            Tw._macros[name].apply(this, args);\n        }\n\n        return this;\n    };\n\n\n    /**\n     * Get/Set an easing function for the tween\n     * \n     * @param {string|array} [value] You could pass a string shortcut for easing registered in Tweene.easings or a 4-length array that represents \n     * a cubic bezier curve\n     * @returns {string|array|this}\n     */\n    this.easing = function(value)\n    {\n        if(value === void 0)\n        {\n            return this._easing;\n        }            \n        this._easing = value;\n        return this;\n    };\n\n\n    /**\n     * Parse arguments and set internal properties, expecting an object considered as \"from\" style properties\n     * \n     * @returns {this}\n     */\n    this.from = function()\n    {\n        this.parseArguments(arguments, true, false);        \n        this.invalidate();\n        return this;\n    };\n\n\n    /**\n     * Parse arguments and set internal properties, expecting an object considered as \"from\" style properties and another one considered as \"to\" style properties\n     * \n     * @returns {this}\n     */\n    this.fromTo = function()\n    {\n        this.parseArguments(arguments, true, true);        \n        this.invalidate();\n        return this; \n    };\n\n\n    /**\n     * Parse arguments and set internal properties, expecting an object considered as \"to\" style properties\n     * \n     * @returns {this}\n     */\n    this.to = function()\n    {\n        this.parseArguments(arguments, false, true);        \n        this.invalidate();\n        return this;\n    };\n\n\n    /**\n     * Set then style properties\n     * @link http://tweene.com/docs/#then\n     * \n     * @param {object} values\n     * @returns {this}\n     */\n    this.then = function(values)\n    {\n        this._then = values;\n        this.invalidate();\n        return this;\n    };\n\n\n    /**\n     * Change style properties instantly, like $('#target').css()\n     * @link http://tweene.com/docs/#tweenSet\n     * \n     * @param {object} values\n     * @returns {this}\n     */\n    this.set = function(values)\n    {\n        // it runs as a 'to' tween with 0 duration, this allow to schedule it inside a timeline too\n        if(values)\n        {\n            this._to = values;        \n        }\n        this\n            .duration(0)\n            .play();\n        return this;\n    };\n\n\n    /**\n     * Perform internal tasks needed before starting the tween\n     * \n     * @returns {number} - Returns the tween total duration\n     */\n    this.prepare = function()\n    {\n        this._prepare();\n        return this._getTotalDuration();\n    };\n\n\n    /**\n     * Parse all the supported variants for argument syntax in Tweene.to, Tweene.from and Tweene.fromTo. Check docs:\n     * @link http://tweene.com/docs/#tweenTo\n     * @link http://tweene.com/docs/#tweenFrom\n     * @link http://tweene.com/docs/#tweenFromTo\n     * \n     * @param {arguments|array} args\n     * @param {boolean} needFrom\n     * @param {boolean} needTo\n     * @param {boolean} needPos - using timeline shortcuts .to() .from() and .fromTo() also position inside the timeline need to be parsed from arguments\n     * @returns {string|number|this} - if needPos = true, returns parsed position\n     */\n    this.parseArguments = function(args, needFrom, needTo, needPos)\n    {\n        if(!isArray(args))\n        {\n            args = toArray(args);\n        }\n        var values = {events: {}}, pos = null;        \n        if(args.length)\n        {\n            // duration passed before properties, like in GSAP\n            if(isString(args[0]) || isNumber(args[0]))\n            {\n                values.duration = args.shift();\n            }\n\n            if(args.length)\n            {\n                if(needFrom)\n                {\n                    values = this._parseDataArg(args.shift(), 'from', values);\n                }\n\n                if(args.length)\n                {      \n                    if(needTo)\n                    {\n                        values = this._parseDataArg(args.shift(), 'to', values);\n                    }\n\n                    if(args.length)\n                    {\n                        // if not yet passed, check for duration param after the style properties \n                        if(!('duration' in values) && (isString(args[0]) || isNumber(args[0])))\n                        {\n                            values.duration = args.shift();\n                        }\n\n                        if(args.length)\n                        {\n                            // timeline position, when needed, is expected here after duration\n                            if(needPos && (isString(args[0]) || isNumber(args[0])))\n                            {\n                                pos = args.shift();\n                            }\n\n                            if(args.length)\n                            {                            \n                                if(isString(args[0]) || isArray(args[0]))\n                                {\n                                    values.easing = args.shift();\n                                }\n                                else if(!isFunction(args[0]))\n                                {           \n                                    values = this._parseDataArg(args.shift(), 'then', values);\n                                }\n                            }\n                        }\n\n                        // complete callback \n                        if(args.length && isFunction(args[0]))\n                        {\n                            var evt = ['end', args.shift()];\n                            if(args.length)\n                            {\n                                evt.push(isArray(args[0])? args[0] : [args[0]]);\n                                if(args.length)\n                                {\n                                    evt.push(args.shift());\n                                }\n                            }\n                            values.events.end = evt;\n                        }\n                    }\n                }\n            }\n        }\n\n        this._applyArguments(values);\n        if(needPos)\n        {\n            return pos;\n        }\n        return this;        \n    };\n\n\n    /**\n     * Clear the internal _data cache \n     * \n     */\n    this._reset = function()\n    {\n        this._data = null;\n    };\n\n    \n    /**\n     * Perform internal tasks needed before starting the tween\n     * \n     * @returns {this}\n     */\n    this._prepare = function()\n    {\n        if(!this._ready)\n        {   \n            this._reset();\n\n            if(this._emulatedProgress)\n            {\n                // stop the progress ticker on both ends of the tween\n                this\n                    .setCoreHandler('end', '_progress', this._stopProgress, this, [])\n                    .setCoreHandler('reverse', '_progress', this._stopProgress, this, []);                \n            }\n\n            // fill data with all time values converted to the unit used by the current driver\n            this._data = {\n                delay: convertTime(this._delay, this._coreTimeUnit, this._driverTimeUnit),\n                loopsDelay: convertTime(this._loopsDelay, this._coreTimeUnit, this._driverTimeUnit),\n                duration: convertTime(this._duration, this._coreTimeUnit, this._driverTimeUnit),\n                speed: this._speed,\n                easing: this._easing\n            };        \n\n            this._data.realDuration = this._data.duration / this.getRealSpeed();\n\n            // flags needed for further actions\n            this._hasBegin = false;\n            this._hasEnd = false;\n            this._hasThen = false;\n            this._hasTween = false;\n            this._hasPre = false;\n            this._hasMultipleEasing = false;\n            \n            // init data structures for handling display and visibility special properties \n            this._hasStaticProps = false;\n            this._staticProps = [];\n            this._display = {pre: null, begin: null, end: null, then: null, mask: 0};\n            this._visibility = {pre: null, begin: null, end: null, then: null, mask: 0};\n\n            this._data.tween = this._prepareProperties(this._from, this._to, this._then);                        \n\n            this._ready = true;\n        }\n        return this;        \n    };    \n\n\n    /**\n     * Return the number of dom elements selected as target for this tween. If the specific library used does not support target objects\n     * with a length property, this method should be overriden in the driver class\n     * \n     * @returns {number}\n     */\n    this._getTargetLength = function()\n    {\n        return this._target.length;\n    };\n\n\n    /**\n     * Create a common data structure after processing data hold in from, to and then objects, if set\n     * \n     * @param {object|null} from\n     * @param {object|null} to\n     * @param {object|null} then\n     * @returns {object|array}\n     */\n    this._prepareProperties = function(from, to, then)\n    {        \n        var tween = {};\n        this._prepareSingle(tween, to, 'end');\n        this._prepareSingle(tween, from, 'begin');\n        this._prepareSingle(tween, then, 'then');\n        \n        // if the used animation library does not have native support for play / pause / reverse / resume, it creates a clone of tween structure \n        // for each single dom target involved\n        if(this._emulatedPlayhead)\n        {\n            var i, end, \n                sortedTween = {}, \n                tweens = [],\n                name,\n                transformOrder = [\n                    'x', 'translateX', 'y', 'translateY', 'z', 'translateZ', \n                    'rotateZ', 'rotate', 'rotation', 'rotationZ', 'rotateX', 'rotationX', 'rotateY', 'rotationY', \n                    'scale', 'scaleX', 'scaleY', 'scaleZ' \n                ]\n            ;\n            \n            for(i = 0, end = transformOrder.length; i < end; i++)\n            {\n                name = transformOrder[i];\n                if(name in tween)\n                {\n                    sortedTween[name] = tween[name];\n                    delete tween[name];\n                }\n            }\n            \n            tween = extendObject(sortedTween, tween);\n                                                            \n            for(i = 0, end = this._getTargetLength(); i < end; i++)\n            {\n                tweens[i] = cloneObject(tween, true);\n            }\n            return tweens;\n        }\n        return tween;                \n    };    \n\n\n    \n\n\n    /**\n     * Process one block of properties\n     * \n     * @param {object} tween\n     * @param {object} block - one of from, to, then\n     * @param {string} type - 'begin' | 'end' | 'then'\n     */\n    this._prepareSingle = function(tween, block, type)\n    {\n        if(block)\n        {\n            block = this._parsePropertiesNames(block);\n            var data;\n            // bit mask used for display and visibility properties\n            // 1 = then, 2 = 'end', 4 = 'begin'. In case of 'end', value is copied in then too, so 3 is used instead of 2\n            var maskValue = type == 'then'? 1 : (type == 'end'? 3 : 4);\n            // _hasBegin | _hasEnd | _hasThen\n            var hasField = '_has' + type.substr(0, 1).toUpperCase() + type.substr(1);\n            for(var name in block)\n            {\n                if(block.hasOwnProperty(name))\n                {\n                    var easing = null, value = block[name], found;\n\n                    // per-property easing \n                    if(isArray(value))\n                    {\n                        easing = this._allowMultipleEasing? value[1] : null;\n                        value = value[0];\n\n                        // per-property easing passed with then object is ignored\n                        this._hasMultipleEasing = (easing && type != 'then');\n                    }\n\n                    if(name == 'display' || name == 'visibility')\n                    {\n                        this['_' + name][type] = value;\n                        this._hasStaticProps = true;\n                        this['_' + name].mask |= maskValue;            \n                        // 'then' object is processed after 'end', so if there is a static property there too, it will overwrite correctly the one set by 'end' call\n                        if(type == 'end')\n                        {\n                            this['_' + name].then = value;                            \n                        }\n                        continue;\n                    }\n\n                    this[hasField] = true;\n                    if(type != 'then')\n                    {\n                        this._hasTween = true;\n                    }\n\n                    if(type == 'end' || !(name in tween))\n                    {\n                        found = false;\n                        data = {\n                            pre: null,\n                            begin: null, \n                            end: null, \n                            then: null,\n                            easing: null, \n                            isTransform: false\n                        };                        \n                    }\n                    else\n                    {\n                        found = true;\n                        data = tween[name];\n                    }\n\n                    data[type] = value;\n\n                    if(type != 'then')\n                    {\n                        if(!found)\n                        {\n                            data.easing = easing;\n                        }\n                    }                    \n\n                    if(!data.isTransform)\n                    {\n                        data.isTransform = isTransformProperty(name);\n                    }                        \n\n                    tween[name] = data;\n                }\n            }\n        }                \n    };\n\n\n    /**\n     * utility function for splitting tween style values when per-property easing is specified\n     * currently used only by GSAP driver, so for simplicity it assumes that this._emulatePlayhead is false and tween data is not cloned \n     * for each dom target\n     * \n     * @param {objet} tween\n     * @returns {array}\n     */\n    this._splitEasing = function(tween)\n    {\n        var map = {},\n            tweens = [],\n            name, easing, easingName, entry;\n\n        for(name in tween)\n        {\n            entry = tween[name];\n            easing = entry.easing? entry.easing : this._easing; \n            // easing could be a string or an array, so we normalize array values to a string in order to have a proper value for the easing map\n            easingName = (isString(easing))? easing : easing.join('_').replace(/\\./g, 'p');\n            if(!(easingName in map))\n            {\n                map[easingName] = tweens.length;\n                tweens.push({tween: {}, easing: easing});\n            }\n            tweens[map[easingName]].tween[name] = entry;            \n        }\n        return tweens;                        \n    };\n\n\n    /**\n     * Perform several actions on style properties passed\n     * \n     * @param {object} values\n     * @returns {object}\n     */\n    this._parsePropertiesNames = function(values)\n    {\n        var newValues = {}, newName, subValues;\n        for(var name in values)\n        {\n            if(values.hasOwnProperty(name))\n            {\n                // convert dashed names to camelCase version\n                newName = camelize(name);                                            \n                \n                // split compund properties like padding: 10px 20px to a list of single-valued properties\n                if(inArray(compoundNames, newName) !== -1)\n                {\n                    subValues = compoundMapping(newName, values[name]);\n                }\n                // split compound transform properties like translate: 10 20 to a list of single-valued transform properties\n                else if(this._allowTransform && inArray(compoundTransforms, newName) !== -1)\n                {\n                    subValues = transformMapping(newName, values[name]);\n                }\n                else\n                {\n                    subValues = {};\n                    subValues[newName] = values[name];\n                }\n                                    \n                for(name in subValues)\n                {\n                    // if found, replace the given name with the alias accepted by the specific animation library\n                    newName = name in this._propertyMap? this._propertyMap[name] : name;\n                    // if transformation are not supported (using jQuery as animation library, for example) any transform property is dropped\n                    if(this._allowTransform || !isTransformProperty(newName))\n                    {\n                        newValues[newName] = subValues[name];                    \n                    }\n                }\n            }\n        }\n        return newValues;\n    };\n\n\n    /**\n     * Transform the given easing value in the form accepted by the specific animation library. In most of the case, the driver has to override \n     * _getBezierEasing() method \n     * \n     * @param {string|array} value\n     * @returns {string|array|function}\n     */    \n    this._getRealEasing = function(value)\n    {\n        // check for shortcut set in Tweene.easings\n        if(isString(value) && value in easings)\n        {\n            value = easings[value];\n        }\n\n        // cubic bezier curve array\n        if(isArray(value) && value.length == 4)\n        {\n            value = this._getBezierEasing(value);\n        }\n\n        return value;\n    };\n\n\n    /**\n     * Duplicate style properties object and check for any options and event handlers passed together\n     * \n     * @param {object} data - only plain object accepted, else it throws an exception \n     * @param {string} name - 'from' | 'to' | 'then'\n     * @param {object} values - destination container\n     * @returns {object}\n     */\n    this._parseDataArg = function(data, name, values)\n    {        \n        if(!seemsPlainObject(data))\n        {\n            throw 'Expected plain object as argument';\n        }\n        data = cloneObject(data, true);    \n        var options = this._parseOptions(data, true);\n        var events = this._parseEvents(data, true);\n        if(keys(data).length)\n        {\n            values[name] = data;\n        }\n        values = extendObject(values, options);\n        values.events = extendObject(values.events, events);\n        return values;\n    };                   \n\n};","/**\n * Tweene - JavaScript Animation Proxy\n *\n * @link http://tweene.com\n *\n * Copyright (c) 2014, Federico Orru'   <federico@buzzler.com>\n *\n * @license Artistic License 2.0\n * See LICENSE.txt for details\n *\n */\n\n\n\n/**\n * Vars and methods common to every timeline object, whatever is the driver used\n * @mixin\n *\n */\nvar TimelineCommon = function()\n{\n    this.type = 'timeline';\n\n    this._offset = 0;\n\n    this._children = [];\n\n    this._cursor = null;\n\n    this._labels = {};\n\n\n    /**\n     * Add tweens, timelines, callbacks and labels to current timeline object\n     * @link http://tweene.com/docs/#timelineAdd\n     * @link http://tweene.com/docs/#nestedTimelines\n     * @link http://tweene.com/docs/#directionalCallbacks\n     * @link http://tweene.com/docs/#labels\n     *\n     * @param {string|object|number} child - number is accepted only when adding directional callback\n     * @param {string|number} [startPosition]\n     * @returns {this}\n     */\n    this.add = function(child, startPosition)\n    {\n        // adding a label\n        if(isString(child))\n        {\n            // label needs to start with an alphabetic character and cannot contains arithmetic symbols specified in the regexp here\n            if(child.search(/^[a-z][^\\+\\-=]*$/) != -1)\n            {\n                child = new Label(child);\n                this._labels[child.id()] = child;\n            }\n            else\n            {\n                throw 'The label \"' + child +'\" contains invalid symbols';\n            }\n        }\n        else\n        {\n            // adding a callback or directional callback\n            if(isFunction(child) || (isNumber(child) && isFunction(startPosition)))\n            {\n                var dir = 0, i = 0;\n                // when a number is passed as first arg, it is a directional callback and we need to shift left the other params\n                if(isNumber(child))\n                {\n                    dir = child;\n                    child = startPosition;\n                    startPosition = arguments[2] || null;\n                    i = 1;\n                }\n                i = i + 2;\n                // params expected after the callback\n                var params = arguments.length > i? (isArray(arguments[i])? arguments[i] : [arguments[i]]) : [];\n                i ++;\n                // callback scope object expected after callback params\n                var scope = arguments.length > i? arguments[i] : null;\n                child = new Callback(child, scope, params, dir, false);\n            }\n\n            child.parent(this);\n        }\n\n        if(startPosition === void 0)\n        {\n            startPosition = null;\n        }\n\n        this._children.push({id: child.id(), child: child, start: startPosition});\n        this.invalidate();\n        return this;\n    };\n\n\n    /**\n     * Add pause, with an optional callback\n     * @link http://tweene.com/docs/#addPause\n     *\n     * @param {string|number} [startPosition]\n     * @param {string|number} [callbackDirection]\n     * @param {function} [callback] - callback\n     * @param {array} [params] - callback params\n     * @param {object} [scope] - callback scope\n     * @returns {this}\n     */\n    this.addPause = function()\n    {\n        var args = toArray(arguments),\n            startPosition = null,\n            dir = 0,\n            callback = null,\n            params = [],\n            scope = null,\n            arg,\n            child;\n\n        if(args.length)\n        {\n            arg = args.shift();\n            if(isFunction(arg))\n            {\n                callback = arg;\n            }\n            else\n            {\n                startPosition = arg;\n            }\n\n            if(args.length)\n            {\n                arg = args.shift();\n                if(!callback)\n                {\n                    if(isNumber(arg))\n                    {\n                        dir = arg;\n                        if(args.length)\n                        {\n                            callback = args.shift();\n                        }\n                    }\n                    else\n                    {\n                        callback = arg;\n                    }\n                }\n\n                if(callback && args.length)\n                {\n                    params = args.shift();\n                    if(!isArray(params))\n                    {\n                        params = [params];\n                    }\n\n                    if(args.length)\n                    {\n                        scope = args.shift();\n                    }\n                }\n            }\n        }\n\n        child = new Callback(callback, scope, params, dir, true);\n        child.parent(this);\n        this._children.push({id: child.id(), child: child, start: startPosition});\n        this.invalidate();\n        return this;\n    };\n\n\n\n    /**\n     * Create a tween and execute a previously registered macro on it\n     * If the timeline has not a target specified, it expects a target as first param.\n     * It expects a position as second (or first) param, all other params are passed to the tween exec() method\n     *\n     * @returns {this}\n     */\n    this.exec = function()\n    {\n        var args = toArray(arguments);\n        if(args.length)\n        {\n            var target = this._target? this._target : args.shift();\n            var tween = Tw.get(target, this.driverName);\n            var pos = args.length > 1?  args.splice(1, 1)[0] : null;\n            this.add(tween, pos);\n            tween.exec.apply(tween, args);\n        }\n        return this;\n    };\n\n    /**\n     * Schedule a tween with duration = 0\n     * @link http://tweene.com/docs/#timelineSet\n     *\n     * @returns {this}\n     */\n    this.set = function()\n    {\n        var args = toArray(arguments);\n        if(args.length)\n        {\n            var target = this._target? this._target : args.shift();\n            var tween = Tw.get(target, this.driverName);\n            if(args.length)\n            {\n                var values = args.shift();\n                var pos = args.length? args.shift() : null;\n                tween._to = values;\n                tween.duration(0);\n                this.add(tween, pos);\n            }\n        }\n        return this;\n    };\n\n\n    /**\n     * Shortcut for .add(Tweene.get().to())\n     * @link http://tweene.com/docs/#timelineTo\n     *\n     * @returns {this}\n     */\n    this.to = function()\n    {\n        return this._tweenMethod(arguments, false, true);\n    };\n\n\n    /**\n     * Shortcut for .add(Tweene.get().fromTo())\n     * @link http://tweene.com/docs/#timelineFromTo\n     *\n     * @returns {this}\n     */\n    this.fromTo = function()\n    {\n        return this._tweenMethod(arguments, true, true);\n    };\n\n\n    /**\n     * Shortcut for .add(Tweene.get().from())\n     * @link http://tweene.com/docs/#timelineFrom\n     *\n     * @returns {this}\n     */\n    this.from = function()\n    {\n        return this._tweenMethod(arguments, true, false);\n    };\n\n\n    /**\n     * used internally for setting child timeline time position inside the parent\n     *\n     * @param {number} value\n     * @returns {this}\n     */\n    this.offset = function(value)\n    {\n        this._offset = value;\n        return this;\n    };\n\n\n    /**\n     * Timeline need to process its children just before starting or when you ask for duration. See implementation in TimelinePro or\n     * in specific drivers\n     *\n     * @returns {this}\n     */\n    this.prepare = function()\n    {\n        if(this._ready)\n        {\n            return this;\n        }\n\n        this._reset();\n        this._mergeChildren();\n        this.ready = true;\n        return this;\n    };\n\n\n    /**\n     * Perform all the common actions needed by .to(), .from() and .fromTo()\n     *\n     * @param {arguments} args\n     * @param {boolean} from\n     * @param {boolean} to\n     * @returns {this}\n     */\n    this._tweenMethod = function(args, from, to)\n    {\n        args = toArray(args);\n        if(args.length)\n        {\n            // use first argument as target if the timeline does not have a global target set\n            var target = this._target? this._target : args.shift();\n            var tween = Tw.get(target, this.driverName);\n            var pos = tween.parseArguments(args, from, to, true);\n            this.add(tween, pos);\n        }\n        return this;\n    };\n\n\n    /**\n     * Process all the children added evaluating their actual time position inside the timeline\n     *\n     * @returns {this}\n     */\n    this._mergeChildren = function()\n    {\n        if(this._ready)\n        {\n            return this;\n        }\n\n        // cursor will contains the end of the last processed child, while duration holds the overall end of the timeline\n        this._cursor = this._duration = 0;\n\n        var child, begin, end, start, childDelay, tweenable;\n        for(var i = 0, len = this._children.length; i < len; i++)\n        {\n            child = this._children[i].child;\n            start = this._children[i].start;\n\n            tweenable = child.type == 'timeline' || child.type == 'tween';\n\n            if(tweenable)\n            {\n                // if the child has a delay, remove it from the child and use it as a start offset inside the timeline\n                childDelay = this._parseTime(child.delay());\n                if(childDelay)\n                {\n                    this._cursor += childDelay;\n                    this._duration += childDelay;\n                    child.delay(0);\n                }\n            }\n\n            // evaluate actual start position\n            begin = this._getStartPosition(this._duration, this._cursor, start);\n\n            if(child.type == 'label')\n            {\n                child.position(begin);\n                this._mergeLabel(child, begin);\n                continue;\n            }\n\n            if(tweenable)\n            {\n                if(child.type == 'timeline')\n                {\n                    child.offset(this._offset + begin);\n                }\n                // prepare() returns totalDuration\n                end = begin + child.prepare();\n                this._mergeTweenable(child, begin, end);\n            }\n            else\n            {\n                // callbacks have duration = 0\n                end = begin;\n                this._mergeCallback(child, begin, end);\n            }\n\n            // an infinite loop in a child tween or timeline results in its duration = Infinity\n            if(end != Infinity)\n            {\n                this._cursor = end;\n                if(this._cursor > this._duration)\n                {\n                    this._duration = this._cursor;\n                }\n            }\n            else\n            {\n                this._cursor = this._duration = Infinity;\n            }\n        }\n        return this;\n    };\n\n\n    /**\n     * Evaluate actual time position of a child inside a timeline\n     *\n     * @param {number} currentDuration\n     * @param {number} currentCursor - end of the previously processed child\n     * @param {string|number} startPosition\n     *\n     * @returns {number}\n     */\n    this._getStartPosition = function(currentDuration, currentCursor, startPosition)\n    {\n        // by default, add to the end of the timeline, obtaining a queue of not-overlapping tweens\n        if(startPosition === null)\n        {\n            return currentDuration;\n        }\n        var start = currentDuration, pos, sign = 0, toCursor = false;\n        if(isString(startPosition))\n        {\n            // parts:\n            //  1 - label\n            //  2 - relative operator, +=, ++=, -=, --=\n            //  3 - time value, number or string with 's' or 'ms' suffix\n            var parts = startPosition.match(/^([a-z][^\\+\\-=]*)?(?:(\\+{1,2}|\\-{1,2})=)?([^\\+\\-=]+)?$/i);\n            if(parts === null)\n            {\n                return currentDuration;\n            }\n\n            pos = parts[3] !== void 0? this._parseTime(parts[3]) : 0;\n\n            if(parts[2] !== void 0)\n            {\n                toCursor = parts[2].length == 2;\n                sign = parts[2].substr(0, 1) == '-'? -1 : 1;\n            }\n\n            if(parts[1] !== void 0 && parts[1] in this._labels)\n            {\n                start = this._labels[parts[1]].position();\n                if(!sign)\n                {\n                    pos = 0;\n                    sign = 1;\n                }\n            }\n            else\n            {\n                if(sign)\n                {\n                    start = toCursor? currentCursor: currentDuration;\n                }\n                else\n                {\n                    start = 0;\n                    sign = 1;\n                }\n            }\n        }\n        else\n        {\n            start = 0;\n            sign = 1;\n            pos = this._parseTime(startPosition);\n        }\n\n        if(start == Infinity)\n        {\n            return Infinity;\n        }\n\n        // cannot add child in negative positions, fallback to 0\n        return Math.max(0, start + (pos * sign));\n    };\n\n};\n","/**\n * Tweene - JavaScript Animation Proxy\n *\n * @link http://tweene.com\n *\n * Copyright (c) 2014, Federico Orru'   <federico@buzzler.com>\n *\n * @license Artistic License 2.0\n * See LICENSE.txt for details\n *\n */\n\n\n/**\n * Vars and methods common to Gsap tween and timeline drivers\n * @mixin\n */\nvar GsapCommon = function()\n{\n\n    this._driverTimeUnit = 's';\n\n    this._native = null;\n\n    this._eventsTarget = null;\n\n    this._eventsSet = false;\n\n\n    /**\n     * Return the native TimelineMax object used internally by tween and timeline\n     *\n     * @returns {object} - TimelineMax object\n     */\n    this.getNative = function()\n    {\n        this.prepare();\n        return this._native;\n    };\n\n\n    /**\n     * Get current time position, needed only by info methods like time() and progress()\n     *\n     * @returns {number}\n     */\n    this._getPosition = function()\n    {\n        if(!this._ready)\n        {\n            return 0;\n        }\n        return convertTime(this._native.time(), this._driverTimeUnit, this._coreTimeUnit);\n    };\n\n\n    /**\n     * Get the current percent progress, as a value between 0 and 1\n     *\n     * @returns {number}\n     */\n    this._getProgress = function()\n    {\n        if(!this._ready)\n        {\n            return 0;\n        }\n        return this._native.progress();\n    };\n\n\n    /**\n     * Get the current running status\n     *\n     * @returns {bolean}\n     */\n    this._getPaused = function()\n    {\n        return (!this._ready || this._native.paused());\n    };\n\n\n    /**\n     * Map Tweene event handlers to native Gsap events\n     *\n     */\n    this._setupEvents = function()\n    {\n        if(this._eventsSet)\n        {\n            return;\n        }\n        var self = this, target, name;\n        this.setCoreHandler('begin', '_running', function() { self._running = true; });\n\n        this._eventsSet = true;\n\n        var eventMaps = {\n            begin: 'onStart',\n            end: 'onComplete',\n            loop: 'onRepeat',\n            reverse: 'onReverseComplete',\n            progress: 'onUpdate'\n        };\n\n        for(name in eventMaps)\n        {\n            if(this._hasHandlers(name))\n            {\n                target = name == 'end'? this._native : this._eventsTarget;\n                target.eventCallback(eventMaps[name], this._runHandlers, [name], this);\n            }\n        }\n    };\n\n\n    /**\n     * Propagate a call to the internal native object\n     *\n     * @param {string} name - method name\n     */\n    this._callNative = function(name)\n    {\n        this.prepare();\n        this._setupEvents();\n        this._native[name]();\n    };\n\n\n    /**\n     * Propagate play() to native object\n     *\n     */\n    this._playTween = function()\n    {\n        this._callNative('play');\n    };\n\n\n    /**\n     * Propagate pause() to native object\n     *\n     */\n    this._pauseTween = function()\n    {\n        this._callNative('pause');\n    };\n\n\n    /**\n     * Propagate resume() to native object\n     *\n     */\n    this._resumeTween = function()\n    {\n        this._callNative('resume');\n    };\n\n\n    /**\n     * Propagate reverse() to native object\n     *\n     */\n    this._reverseTween = function()\n    {\n        this._callNative('reverse');\n    };\n\n\n    /**\n     * Propagate restart() to native object\n     *\n     */\n    this._restartTween = function()\n    {\n        this._callNative('restart');\n    };\n\n\n    /**\n     * Map speed() calls to native timeScale() method\n     *\n     */\n    this._speedTween = function()\n    {\n        if(this._native && !this._parent)\n        {\n            this._native.timeScale(this._speed);\n        }\n    };\n\n};\n\n\n/**\n * Gsap Tween Driver\n * @link http://greensock.com/gsap\n *\n * @mixes Common, TweenCommon, GsapCommon\n *\n */\nTw.registerDriver('Gsap', 'tween', function(){\n    Common.call(this);\n    TweenCommon.call(this);\n    GsapCommon.call(this);\n\n    this._allowMultipleEasing = true;\n    this._allowTransform = true;\n\n    this._propertyMap = {\n        translateX: 'x',\n        translateY: 'y',\n        translateZ: 'z',\n        rotate: 'rotation',\n        rotateX: 'rotationX',\n        rotateY: 'rotationY',\n        rotateZ: 'rotationZ'\n    };\n\n\n\n    /**\n     * Override TweenCommon._reset()\n     *\n     */\n    this._reset = function()\n    {\n        if(this._native)\n        {\n            this._native.clear();\n            this._native = null;\n        }\n        this._eventsTarget = null;\n        this._eventsSet = false;\n    };\n\n\n    /**\n     * Get a Gsap generic Ease object constructed with a cubic bezier easing function\n     *\n     * @param {array} value\n     * @returns {object}\n     */\n    this._getBezierEasing = function(value)\n    {\n        return new Ease(bezier.apply(null, value));\n    };\n\n\n    /**\n     * Override TweenCommon.prepare()\n     *\n     * @returns {number}\n     */\n    this.prepare = function()\n    {\n        this._prepare();\n\n        if(this._native !== null)\n        {\n            return this;\n        }\n\n        var\n            data = this._data,\n            from, to,\n            then = {},\n            i, end, tween, name, elem, fromCount, toCount, thenCount = 0;\n\n        this._native = new TimelineMax({\n            delay: data.delay\n        })\n            .pause()\n            .timeScale(this._speed);\n\n        // with Gsap we do per-property easing with overlapping tweens of the same targets\n        data.tween = this._hasMultipleEasing? this._splitEasing(data.tween) : [{tween: data.tween, easing: data.easing}];\n\n        for(i = 0, end = data.tween.length; i < end; i++)\n        {\n            tween = data.tween[i].tween;\n\n            fromCount = 0;\n            toCount = 0;\n            from = {};\n            to = {};\n\n            for(name in tween)\n            {\n                if(tween[name].begin !== null)\n                {\n                    fromCount ++;\n                    from[name] = tween[name].begin;\n                }\n\n                if(tween[name].end !== null)\n                {\n                    toCount ++;\n                    to[name] = tween[name].end;\n                }\n\n                if(tween[name].then !== null)\n                {\n                    thenCount ++;\n                    then[name] = tween[name].then;\n                }\n            }\n\n            var values = (this._hasEnd)? to : from;\n            if(data.duration)\n            {\n                values.ease = this._getRealEasing(data.tween[i].easing);\n            }\n\n            // in order to achieve almost the same behavior in all the drivers, it runs always with immediateRender = false\n            values.immediateRender = false;\n            values.paused = true;\n            if(this._loops !== 0)\n            {\n                values.repeat = this._loops;\n                values.repeatDelay = data.loopsDelay;\n            }\n            if(this._yoyo)\n            {\n                values.yoyo = true;\n            }\n\n            // add display and visibility properties\n\n            if(toCount)\n            {\n                if(this._display.end)\n                {\n                    to.display = this._display.end;\n                }\n                if(this._visibility.end)\n                {\n                    if(this._visibility.end == 'hidden')\n                    {\n                        thenCount++;\n                        then.visibility = this._visibility.end;\n                    }\n                    else\n                    {\n                        to.visibility = this._visibility.end;\n                    }\n                }\n            }\n\n            var duration = Math.max(0, data.duration - 0.000001);\n            if(fromCount)\n            {\n                if(this._display.begin)\n                {\n                    from.display = this._display.begin;\n                }\n                if(this._visibility.begin)\n                {\n                    from.visibility = this._visibility.begin;\n                }\n\n                if(toCount)\n                {\n                    elem = TweenMax.fromTo(this._target, duration, from, to);\n                }\n                else\n                {\n                    elem = TweenMax.from(this._target, duration, from);\n                }\n            }\n            else if(toCount)\n            {\n                elem = TweenMax.to(this._target, duration, to);\n            }\n            else\n            {\n                elem = TweenMax.to(this._target, duration, {opacity: '+=0'});\n            }\n\n\n            // we add events only to the first tween\n            if(i === 0)\n            {\n                this._eventsTarget = elem;\n            }\n\n            // avoid from bug when nested inside timelines\n            // @link http://greensock.com/forums/topic/10418-fromto-seems-to-ignore-immediaterender-false-when-nested/\n            this._native.add(elem, 0.000001);\n            elem.paused(false);\n        }\n\n        if(this._display.then)\n        {\n            thenCount++;\n            then.display = this._display.then;\n        }\n        if(this._visibility.then)\n        {\n            thenCount++;\n            then.visibility = this._visibility.then;\n        }\n\n        if(thenCount)\n        {\n            this._native.to(this._target, 0, then, data.duration);\n        }\n\n        this._setupEvents();\n\n        return this._getTotalDuration();\n    };\n\n\n});\n\n\n\n/**\n * Gsap Timeline Driver\n *\n * @mixes Common, TimelineCommon, GsapCommon\n *\n */\nTw.registerDriver('Gsap', 'timeline', function(){\n    Common.call(this);\n    TimelineCommon.call(this);\n    GsapCommon.call(this);\n\n    this._innerNative = null;\n\n\n    /**\n     * Override TimelineCommon.prepare()\n     *\n     * @returns {number}\n     */\n    this.prepare = function()\n    {\n        if(this._ready)\n        {\n            return this;\n        }\n\n        var values = {paused: true};\n        if(this._loops)\n        {\n            values.repeat = this._loops;\n            values.repeatDelay = convertTime(this._loopsDelay, this._coreTimeUnit, this._driverTimeUnit);\n        }\n\n        if(this._yoyo)\n        {\n            values.yoyo = true;\n        }\n\n        var _native = new TimelineMax(values);\n\n        if(this._parent)\n        {\n            this._native = _native;\n        }\n        else\n        {\n            this._native = new TimelineMax({paused: true, delay: convertTime(this._delay, this._coreTimeUnit, this._driverTimeUnit)})\n                .add(_native);\n            _native.paused(false);\n        }\n\n        this._innerNative = _native;\n        this._native.timeScale(this._speed);\n        this._eventsTarget = _native;\n        this._setupEvents();\n\n        this._mergeChildren();\n        this._ready = true;\n        return this._getTotalDuration();\n    };\n\n\n    /**\n     * Override TimelineCommon._reset()\n     *\n     */\n    this._reset = function()\n    {\n        this._offset = 0;\n        this._cursor = null;\n        if(this._native)\n        {\n            this._native.clear();\n            this._innerNative.clear();\n            this._native = null;\n            this._innerNative = null;\n        }\n        this._eventsTarget = null;\n        this._eventsSet = false;\n    };\n\n\n    /**\n     * Override TimelineCommon._mergeLabel()\n     *\n     */\n    this._mergeLabel = function(child, begin)\n    {\n        // nop\n    };\n\n\n    /**\n     * Override TimelineCommon._mergeTweenable()\n     *\n     */\n    this._mergeTweenable = function(child, begin, end)\n    {\n        if(begin != Infinity)\n        {\n            var childNative = child.getNative();\n            this._innerNative.add(childNative, convertTime(begin, this._coreTimeUnit, this._driverTimeUnit));\n            childNative.paused(false);\n        }\n    };\n\n\n    /**\n     * Override TimelineCommon._mergeCallback()\n     *\n     */\n    this._mergeCallback = function(child, begin, end)\n    {\n        if(begin != Infinity)\n        {\n            if(child.isPause)\n            {\n                this._native.addPause(convertTime(begin + this._delay, this._coreTimeUnit, this._driverTimeUnit), child.resume, [], child);\n            }\n            else\n            {\n                this._innerNative.call(child.resume, [], child, convertTime(begin, this._coreTimeUnit, this._driverTimeUnit));\n            }\n        }\n    };\n\n\n\n});\n\n\nTw.defaultTimeUnit = 's';\nTw.defaultDriver = 'gsap';\n"],"sourceRoot":"/source/"}